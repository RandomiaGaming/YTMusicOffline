using System;
using System.Collections.Generic;
using System.IO;
using Newtonsoft.Json;

public sealed class SongData
{
    public string VideoID = null;
    public string ThumbnailUrl = null;
    public TimeSpan? ContentDuration = null;
    public string SongName = null;
    public string AlbumName = null;
    public DateTime? ReleaseDate = null;
    public string[] ArtistNames = null;
    public bool YTMusicSong = false;
}
public sealed class YTMusicData
{
    public string ProvidedBy = null;
    public string SongName = null;
    public string[] ArtistNames = null;
    public string AlbumName = null;
    public string[] PublishStatements = null;
    public DateTime? ReleasedOn = null;
    public Tuple<string, string>[] RoleNamePairs = null;
}
public static class SongDataParser
{
    public static void Run(string inputFilePath, string outputFilePath)
    {
        Console.WriteLine($"Loading input from \"{inputFilePath}\"...");
        List<PlaylistData> playlists = YTDataDownloader.LoadData(inputFilePath);
        Console.WriteLine("Parsing songs...");
        List<SongData> songs = new List<SongData>();
        foreach (PlaylistData playlist in playlists)
        {
            foreach (VideoData video in playlist.Videos)
            {
                ParseSong(video, songs);
            }
        }
        Console.WriteLine($"Saving output to \"{outputFilePath}\"...");
        SaveData(songs, outputFilePath);
    }
    private static void ParseSong(VideoData video, List<SongData> songs)
    {
        // Ignore duplicate songs
        foreach (SongData song in songs)
        {
            if (song.VideoID == video.VideoID)
            {
                return;
            }
        }

        // Ignore deleted or private videos
        if (video.ThumbnailUrl == null && video.ChannelID == null && video.ChannelTitle == null && video.UploadDate == null)
        {
            return;
        }

        // Parse basic information from video metadata
        SongData songData = new SongData();
        songData.VideoID = video.VideoID;
        songData.ThumbnailUrl = video.ThumbnailUrl;
        songData.ContentDuration = video.ContentDuration;
        songData.SongName = video.Title;
        songData.AlbumName = null;
        songData.ReleaseDate = video.UploadDate;
        songData.ArtistNames = new string[1] { video.ChannelTitle };
        if (songData.ArtistNames[0].EndsWith(" - Topic"))
        {
            songData.ArtistNames[0] = songData.ArtistNames[0].Substring(0, songData.ArtistNames[0].Length - 8);
        }
        songData.YTMusicSong = false;

        // Check for YTMusic auto-generated description
        string videoDescription = video.Description.Replace("\r\n", "\n");
        if (videoDescription.EndsWith("\n\nAuto-generated by YouTube."))
        {
            // If present split the sections
            songData.YTMusicSong = true;
            YTMusicData ytMusicData = new YTMusicData();
            string ytMusicDescription = videoDescription.Substring(0, videoDescription.Length - "\n\nAuto-generated by YouTube.".Length);
            string[] sections = Split(ytMusicDescription, "\n\n");
            int currentSection = 0;

            // Parse each section and skip sections which are not present
            if (ParseProvidedBy(currentSection < sections.Length ? sections[currentSection] : null, ytMusicData))
            {
                currentSection++;
            }
            ParseSongAndArtist(currentSection < sections.Length ? sections[currentSection] : null, ytMusicData);
            {
                currentSection++;
            }
            ParseAlbumName(currentSection < sections.Length ? sections[currentSection] : null, ytMusicData);
            {
                currentSection++;
            }
            if (ParsePublishInfo(currentSection < sections.Length ? sections[currentSection] : null, ytMusicData))
            {
                currentSection++;
            }
            if (ParseReleasedOn(currentSection < sections.Length ? sections[currentSection] : null, ytMusicData))
            {
                currentSection++;
            }
            if (ParseRoleNamePairs(currentSection < sections.Length ? sections[currentSection] : null, ytMusicData))
            {
                currentSection++;
            }

            // Check for errors
            if (currentSection != sections.Length)
            {
                throw new Exception("Parsing YTMusic auto generated description failed.");
            }

            // Update data if more accurate data was found in the description
            if (ytMusicData.SongName != null)
            {
                songData.SongName = ytMusicData.SongName;
            }
            if (ytMusicData.AlbumName != null)
            {
                songData.AlbumName = ytMusicData.AlbumName;
            }
            if (ytMusicData.ReleasedOn != null)
            {
                songData.ReleaseDate = ytMusicData.ReleasedOn;
            }
            if (ytMusicData.ArtistNames != null)
            {
                songData.ArtistNames = ytMusicData.ArtistNames;
            }
        }

        songs.Add(songData);
    }

    private static bool ParseProvidedBy(string section, YTMusicData ytMusicData)
    {
        if (section == null)
        {
            return false;
        }
        if (!section.StartsWith("Provided to YouTube by "))
        {
            return false;
        }
        string providedBy = section.Substring("Provided to YouTube by ".Length);
        if (providedBy == "")
        {
            return false;
        }
        if (providedBy.Contains("\n"))
        {
            return false;
        }
        ytMusicData.ProvidedBy = providedBy;
        return true;
    }
    private static void ParseSongAndArtist(string section, YTMusicData ytMusicData)
    {
        if (section == null)
        {
            throw new Exception("No value provided for required section SongAndArtist.");
        }
        string[] names = Split(section, " · ");
        if (names.Length < 2)
        {
            throw new Exception("Section SongAndArtist must contain at least 2 values.");
        }
        foreach (string name in names)
        {
            if (name == "")
            {
                throw new Exception("Name may not be empty.");
            }
            if (name.Contains("\n"))
            {
                throw new Exception("Name contained invalid characters.");
            }
        }
        ytMusicData.SongName = names[0];
        ytMusicData.ArtistNames = new string[names.Length - 1];
        Array.Copy(names, 1, ytMusicData.ArtistNames, 0, ytMusicData.ArtistNames.Length);
    }
    private static void ParseAlbumName(string section, YTMusicData ytMusicData)
    {
        if (section == null)
        {
            throw new Exception("No value provided for required section AlbumName.");
        }
        string albumName = section;
        if (albumName == "")
        {
            throw new Exception("AlbumName may not be empty.");
        }
        if (albumName.Contains("\n"))
        {
            throw new Exception("AlbumName contained invalid characters.");
        }
        ytMusicData.AlbumName = albumName;
    }
    private static bool ParsePublishInfo(string section, YTMusicData ytMusicData)
    {
        if (section == null)
        {
            return false;
        }
        string[] publishStatements = Split(section, "\n");
        foreach (string publishStatement in publishStatements)
        {
            if (publishStatement == "")
            {
                return false;
            }
            if (!publishStatement.StartsWith("℗ "))
            {
                return false;
            }
            if (publishStatement.Contains("\n"))
            {
                return false;
            }
        }
        ytMusicData.PublishStatements = publishStatements;
        return true;
    }
    private static bool ParseReleasedOn(string section, YTMusicData ytMusicData)
    {
        if (section == null)
        {
            return false;
        }
        if (!section.StartsWith("Released on: "))
        {
            return false;
        }
        string releasedOnString = section.Substring("Released on: ".Length);
        if (releasedOnString == "")
        {
            return false;
        }
        if (releasedOnString.Contains("\n"))
        {
            return false;
        }
        DateTime releasedOn;
        if (!DateTime.TryParse(releasedOnString, out releasedOn))
        {
            return false;
        }
        ytMusicData.ReleasedOn = releasedOn;
        return true;
    }
    private static bool ParseRoleNamePairs(string section, YTMusicData ytMusicData)
    {
        if (section == null)
        {
            return false;
        }
        string[] roleNamePairs = Split(section, "\n");
        Tuple<string, string>[] roleNamePairsParsed = new Tuple<string, string>[roleNamePairs.Length];
        for (int i = 0; i < roleNamePairs.Length; i++)
        {
            string roleNamePair = roleNamePairs[i];
            int index = roleNamePair.IndexOf(": ");
            if (index == -1)
            {
                return false;
            }
            string role = roleNamePair.Substring(0, index);
            string name = roleNamePair.Substring(index + ": ".Length);
            if (role == "")
            {
                return false;
            }
            if (role.Contains("\n"))
            {
                return false;
            }
            if (name == "")
            {
                return false;
            }
            if (name.Contains("\n"))
            {
                return false;
            }
            Tuple<string, string> roleNamePairParsed = new Tuple<string, string>(role, name);
            roleNamePairsParsed[i] = roleNamePairParsed;
        }
        ytMusicData.RoleNamePairs = roleNamePairsParsed;
        return true;
    }

    private static string[] Split(string value, string separator)
    {
        List<string> output = new List<string>();
        while (true)
        {
            int i = value.IndexOf(separator);
            if (i == -1)
            {
                output.Add(value);
                break;
            }
            else
            {
                output.Add(value.Substring(0, i));
                value = value.Substring(i + separator.Length);

                if (value.Length == 0)
                {
                    output.Add("");
                    break;
                }
            }
        }
        return output.ToArray();
    }

    private static void SaveData(List<SongData> data, string filePath)
    {
        string json = JsonConvert.SerializeObject(data, Formatting.Indented);
        File.WriteAllText(filePath, json);
    }
    public static List<SongData> LoadData(string filePath)
    {
        string json = File.ReadAllText(filePath);
        return JsonConvert.DeserializeObject<List<SongData>>(json);
    }
}